package mixed

// TwoSum находит индексы двух чисел в массиве, сумма которых равна целевому значению.
//
// Задача:
//
//	Найти два различных элемента в массиве, сумма которых равна target.
//	Вернуть индексы этих элементов. Гарантируется, что решение существует и единственно.
//
// Сигнатура функции:
//
//	func TwoSum(nums []int, target int) (int, int)
//
// Вход:
//   - nums []int: массив целых чисел
//   - target int: целевая сумма
//
// Выход:
//   - (int, int): индексы двух элементов, сумма которых равна target
//   - Если решения нет, возвращать (-1, -1)
//
// Примеры:
//
//	TwoSum([]int{2, 7, 11, 15}, 9) → (0, 1) // nums[0] + nums[1] = 2 + 7 = 9
//	TwoSum([]int{3, 2, 4}, 6) → (1, 2) // nums[1] + nums[2] = 2 + 4 = 6
//	TwoSum([]int{3, 3}, 6) → (0, 1) // nums[0] + nums[1] = 3 + 3 = 6
//	TwoSum([]int{1, 2, 3, 4, 5}, 8) → (2, 4) // nums[2] + nums[4] = 3 + 5 = 8
//	TwoSum([]int{-1, -2, -3, -4, -5}, -8) → (2, 4) // nums[2] + nums[4] = -3 + (-5) = -8
//	TwoSum([]int{1, 2}, 4) → (-1, -1) // решения нет
//
// Ограничения:
//   - Длина массива от 2 до 10^4
//   - Элементы могут быть отрицательными
//   - Каждый элемент может использоваться только один раз
//   - Возвращайте индексы в любом порядке
//   - Временная сложность: O(n) с использованием hash map
//   - Пространственная сложность: O(n)
//
// Особенности:
//   - Используйте hash map для хранения значений и их индексов
//   - Для каждого элемента ищите complement = target - nums[i]
//   - Проверяйте complement в map перед добавлением текущего элемента
//   - Обработайте случай с дубликатами (например, [3,3], target=6)
//   - Не используйте один элемент дважды
//
// Идиоматичный Go:
//   - Используйте map[int]int для хранения значение -> индекс
//   - Проверяйте существование ключа с помощью value, ok := map[key]
//   - Возвращайте (-1, -1) если решения нет
func TwoSum(nums []int, target int) (int, int) {
	// TODO: Реализуйте функцию
	return -1, -1
}
