package problems

// DedupeSortedInPlace удаляет дубликаты из отсортированного слайса "на месте".
//
// Задача:
//
//	Удалить все дубликаты из отсортированного слайса, изменяя его содержимое
//	и возвращая новую длину уникальных элементов. Элементы должны остаться
//	в том же порядке.
//
// Сигнатура функции:
//
//	func DedupeSortedInPlace(nums []int) int
//
// Вход:
//   - nums []int: отсортированный слайс целых чисел (по возрастанию)
//
// Выход:
//   - int: новая длина слайса после удаления дубликатов
//   - Слайс nums изменяется "на месте" - первые k элементов содержат уникальные значения
//
// Примеры:
//
//	nums := []int{1, 1, 2}
//	length := DedupeSortedInPlace(nums) → 2
//	nums[:length] → []int{1, 2}
//
//	nums := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}
//	length := DedupeSortedInPlace(nums) → 5
//	nums[:length] → []int{0, 1, 2, 3, 4}
//
//	nums := []int{}
//	length := DedupeSortedInPlace(nums) → 0
//
// Ограничения:
//   - Слайс уже отсортирован по возрастанию
//   - Изменения должны происходить "на месте" без выделения дополнительной памяти
//   - Временная сложность: O(n)
//   - Пространственная сложность: O(1)
//
// Особенности:
//   - Используйте технику "два указателя"
//   - Один указатель для чтения, другой для записи
//   - Обработайте пустой слайс
//   - Элементы после позиции length не важны
//
// Идиоматичный Go:
//   - Изменяйте исходный слайс напрямую
//   - Возвращайте новую длину как int
func DedupeSortedInPlace(nums []int) int { //а точно ли write, read можно назвать указателями ? слайс меняется не через прямое обращение к указателям (*read or *write), а слайс меняется обращаясь к ним.

	if len(nums) <= 1 {
		return len(nums)
	}

	write := 1

	for read := 1; read < len(nums); read++ {
		if nums[read] != nums[write-1] {
			nums[write] = nums[read]
			write++
		}
	}

	return write
}
