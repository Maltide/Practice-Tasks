package problems

// RotateRight поворачивает слайс вправо на k позиций.
//
// Задача:
//
//	Повернуть элементы слайса вправо на k позиций. Элементы, которые выходят
//	за правую границу, должны появиться в начале слайса.
//
// Сигнатура функции:
//
//	func RotateRight(nums []int, k int) []int
//
// Вход:
//   - nums []int: исходный слайс целых чисел
//   - k int: количество позиций для поворота вправо
//
// Выход:
//   - []int: новый слайс с повернутыми элементами
//
// Примеры:
//
//	RotateRight([]int{1, 2, 3, 4, 5}, 2) → []int{4, 5, 1, 2, 3}
//	RotateRight([]int{-1, -100, 3, 99}, 2) → []int{3, 99, -1, -100}
//	RotateRight([]int{1, 2}, 3) → []int{2, 1} (k больше длины)
//	RotateRight([]int{1}, 1) → []int{1}
//	RotateRight([]int{}, 1) → []int{}
//
// Ограничения:
//   - k может быть больше длины слайса
//   - k может быть равен 0
//   - Пустой слайс остается пустым
//   - Временная сложность: O(n)
//   - Пространственная сложность: O(n) для нового слайса
//
// Особенности:
//   - Используйте модульную арифметику: k = k % len(nums)
//   - Обработайте случаи k = 0, пустой слайс, k > len(nums)
//   - Рассмотрите алгоритм "тройной разворот" или слайсинг
//
// Идиоматичный Go:
//   - Используйте слайсинг для эффективного поворота
//   - Создайте новый слайс, не изменяя исходный
//   - Обработайте граничные случаи в начале функции
func RotateRight(nums []int, k int) []int {
	if len(nums) == 0 {
		return []int{}
	}

	if k == 0 {
		return nums
	}

	if k > len(nums) {
		k = k % len(nums)
	}

	resultslice := []int{}

	cut := len(nums) - k

	resultslice = append(resultslice, nums[cut:]...)

	resultslice = append(resultslice, nums[:cut]...)

	return resultslice
}
